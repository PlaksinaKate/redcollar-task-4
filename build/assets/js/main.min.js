import{getPosts,getUser,slipPosts,postsTotalLenth}from"./api.min.js";import{POSTS_LIST}from"./contst.min.js";const postsContainer=document.getElementsByClassName(POSTS_LIST)[0];async function posts(){(await getPosts()).posts.forEach((async t=>{const{userId:s}=t;setPostHTML(t,await getUserName(s))}))}function setPostHTML(t,s){const{title:e,body:n,reactions:o,tags:i}=t,a=document.createElement("div");a.classList.add("posts__item"),a.innerHTML=`<div class="posts__item-tags row">${getTags(i)}</div>\n                        <h2 class="posts__item-title">${e}</h2>\n                        <div class="posts__item-text">${n}</div>\n                        <div class="row space-between">\n                          <div class="posts__item-reactions">\n                            <div class="posts__item-reactions-icon"></div>\n                            <div class="posts__item-reactions-number">${o}</div>\n                          </div>\n                          <div class="posts__item-author">${s}</div>\n                        </div>`,postsContainer.appendChild(a)}function getTags(t){let s="";return t.forEach((t=>{s+=`<div class="posts__item-tag">${t}</div>`})),s}async function getUserName(t){try{const s=await getUser(t),{maidenName:e,lastName:n}=s;return`${e} ${n}`}catch(t){throw new Error(t)}}const options={root:document.querySelector(POSTS_LIST),rootMargin:"10px",threshold:.25};async function handleIntersect(t,s){t.forEach((t=>{t.isIntersecting&&posts()}))}const observer=new IntersectionObserver(handleIntersect,options),triggerBtn=document.getElementsByClassName("loading")[0];observer.observe(triggerBtn),setInterval((()=>{postsTotalLenth<=slipPosts&&(triggerBtn.classList.add("hidden"),observer.disconnect(),clearInterval())}),5e3);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5taW4uanMiLCJuYW1lcyI6WyJnZXRQb3N0cyIsImdldFVzZXIiLCJzbGlwUG9zdHMiLCJwb3N0c1RvdGFsTGVudGgiLCJQT1NUU19MSVNUIiwicG9zdHNDb250YWluZXIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJhc3luYyIsInBvc3RzIiwiZm9yRWFjaCIsIml0ZW0iLCJ1c2VySWQiLCJzZXRQb3N0SFRNTCIsImdldFVzZXJOYW1lIiwidXNlck5hbWUiLCJ0aXRsZSIsImJvZHkiLCJyZWFjdGlvbnMiLCJ0YWdzIiwibmV3RGl2IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsImlubmVySFRNTCIsImdldFRhZ3MiLCJhcHBlbmRDaGlsZCIsImh0bWxUYWciLCJ0YWciLCJ1c2VyIiwibWFpZGVuTmFtZSIsImxhc3ROYW1lIiwiZXJyb3IiLCJFcnJvciIsIm9wdGlvbnMiLCJyb290IiwicXVlcnlTZWxlY3RvciIsInJvb3RNYXJnaW4iLCJ0aHJlc2hvbGQiLCJoYW5kbGVJbnRlcnNlY3QiLCJlbnRyaWVzIiwib2JzZXJ2ZXIiLCJlbnRyeSIsImlzSW50ZXJzZWN0aW5nIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJ0cmlnZ2VyQnRuIiwib2JzZXJ2ZSIsInNldEludGVydmFsIiwiZGlzY29ubmVjdCIsImNsZWFySW50ZXJ2YWwiXSwic291cmNlcyI6WyJtYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFBvc3RzLCBnZXRVc2VyLCBzbGlwUG9zdHMsIHBvc3RzVG90YWxMZW50aCB9IGZyb20gJy4vYXBpLm1pbi5qcydcbmltcG9ydCB7IFBPU1RTX0xJU1QgfSBmcm9tICcuL2NvbnRzdC5taW4uanMnXG5jb25zdCBwb3N0c0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoUE9TVFNfTElTVClbMF07XG5cbmFzeW5jIGZ1bmN0aW9uIHBvc3RzKCkge1xuICBjb25zdCBwb3N0cyA9IGF3YWl0IGdldFBvc3RzKClcblxuICBwb3N0cy5wb3N0cy5mb3JFYWNoKGFzeW5jIChpdGVtKSA9PiB7XG4gICAgY29uc3QgeyB1c2VySWQgfSA9IGl0ZW1cbiAgICBjb25zdCB1c2VyTmFtZSA9IGF3YWl0IGdldFVzZXJOYW1lKHVzZXJJZCk7XG4gICAgc2V0UG9zdEhUTUwoaXRlbSwgdXNlck5hbWUpXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRQb3N0SFRNTChpdGVtLCB1c2VyTmFtZSkge1xuICBjb25zdCB7IHRpdGxlLCBib2R5LCByZWFjdGlvbnMsIHRhZ3MgfSA9IGl0ZW07XG5cbiAgY29uc3QgbmV3RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgbmV3RGl2LmNsYXNzTGlzdC5hZGQoJ3Bvc3RzX19pdGVtJylcbiAgbmV3RGl2LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwicG9zdHNfX2l0ZW0tdGFncyByb3dcIj4ke2dldFRhZ3ModGFncyl9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aDIgY2xhc3M9XCJwb3N0c19faXRlbS10aXRsZVwiPiR7dGl0bGV9PC9oMj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwb3N0c19faXRlbS10ZXh0XCI+JHtib2R5fTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJvdyBzcGFjZS1iZXR3ZWVuXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwb3N0c19faXRlbS1yZWFjdGlvbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicG9zdHNfX2l0ZW0tcmVhY3Rpb25zLWljb25cIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicG9zdHNfX2l0ZW0tcmVhY3Rpb25zLW51bWJlclwiPiR7cmVhY3Rpb25zfTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBvc3RzX19pdGVtLWF1dGhvclwiPiR7dXNlck5hbWV9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5gXG5cbiAgcG9zdHNDb250YWluZXIuYXBwZW5kQ2hpbGQobmV3RGl2KVxufVxuXG5mdW5jdGlvbiBnZXRUYWdzKHRhZ3MpIHtcbiAgbGV0IGh0bWxUYWcgPSAnJ1xuICB0YWdzLmZvckVhY2godGFnID0+IHtcbiAgICBodG1sVGFnICs9IGA8ZGl2IGNsYXNzPVwicG9zdHNfX2l0ZW0tdGFnXCI+JHt0YWd9PC9kaXY+YFxuICB9KVxuXG4gIHJldHVybiBodG1sVGFnO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRVc2VyTmFtZSh1c2VySWQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgZ2V0VXNlcih1c2VySWQpXG4gICAgY29uc3QgeyBtYWlkZW5OYW1lLCBsYXN0TmFtZSB9ID0gdXNlclxuICAgIHJldHVybiBgJHttYWlkZW5OYW1lfSAke2xhc3ROYW1lfWBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpXG4gIH1cbn1cblxuY29uc3Qgb3B0aW9ucyA9IHtcbiAgcm9vdDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcihQT1NUU19MSVNUKSxcbiAgcm9vdE1hcmdpbjogJzEwcHgnLFxuICB0aHJlc2hvbGQ6IDAuMjVcbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlSW50ZXJzZWN0KGVudHJpZXMsIG9ic2VydmVyKSB7XG4gIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgIHBvc3RzKClcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVJbnRlcnNlY3QsIG9wdGlvbnMpO1xuY29uc3QgdHJpZ2dlckJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xvYWRpbmcnKVswXVxub2JzZXJ2ZXIub2JzZXJ2ZSh0cmlnZ2VyQnRuKTtcblxuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICBpZiAocG9zdHNUb3RhbExlbnRoIDw9IHNsaXBQb3N0cykge1xuICAgIHRyaWdnZXJCdG4uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJylcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgY2xlYXJJbnRlcnZhbCgpXG4gIH1cbn0sIDUwMDApXG4iXSwibWFwcGluZ3MiOiJPQUFTQSxTQUFVQyxRQUFTQyxVQUFXQyxvQkFBdUIsc0JBQ3JEQyxlQUFrQixrQkFDM0IsTUFBTUMsZUFBaUJDLFNBQVNDLHVCQUF1QkgsWUFBWSxHQUVuRUksZUFBZUMsZUFDT1QsWUFFZFMsTUFBTUMsU0FBUUYsTUFBT0csSUFDekIsTUFBTUMsT0FBRUEsR0FBV0QsRUFFbkJFLFlBQVlGLFFBRFdHLFlBQVlGLEdBQ1QsR0FFOUIsQ0FFQSxTQUFTQyxZQUFZRixFQUFNSSxHQUN6QixNQUFNQyxNQUFFQSxFQUFLQyxLQUFFQSxFQUFJQyxVQUFFQSxFQUFTQyxLQUFFQSxHQUFTUixFQUVuQ1MsRUFBU2QsU0FBU2UsY0FBYyxPQUN0Q0QsRUFBT0UsVUFBVUMsSUFBSSxlQUNyQkgsRUFBT0ksVUFBWSxxQ0FBcUNDLFFBQVFOLG1FQUNWSCxpRUFDQUMsc1JBSWdCQyx3R0FFWkgsMENBRzFEVixlQUFlcUIsWUFBWU4sRUFDN0IsQ0FFQSxTQUFTSyxRQUFRTixHQUNmLElBQUlRLEVBQVUsR0FLZCxPQUpBUixFQUFLVCxTQUFRa0IsSUFDWEQsR0FBVyxnQ0FBZ0NDLFNBQUcsSUFHekNELENBQ1QsQ0FFQW5CLGVBQWVNLFlBQVlGLEdBQ3pCLElBQ0UsTUFBTWlCLFFBQWE1QixRQUFRVyxJQUNyQmtCLFdBQUVBLEVBQVVDLFNBQUVBLEdBQWFGLEVBQ2pDLE1BQU8sR0FBR0MsS0FBY0MsR0FDMUIsQ0FBRSxNQUFPQyxHQUNQLE1BQU0sSUFBSUMsTUFBTUQsRUFDbEIsQ0FDRixDQUVBLE1BQU1FLFFBQVUsQ0FDZEMsS0FBTTdCLFNBQVM4QixjQUFjaEMsWUFDN0JpQyxXQUFZLE9BQ1pDLFVBQVcsS0FHYjlCLGVBQWUrQixnQkFBZ0JDLEVBQVNDLEdBQ3RDRCxFQUFROUIsU0FBU2dDLElBQ1hBLEVBQU1DLGdCQUNSbEMsT0FDRixHQUVKLENBRUEsTUFBTWdDLFNBQVcsSUFBSUcscUJBQXFCTCxnQkFBaUJMLFNBQ3JEVyxXQUFhdkMsU0FBU0MsdUJBQXVCLFdBQVcsR0FDOURrQyxTQUFTSyxRQUFRRCxZQUVqQkUsYUFBWSxLQUNONUMsaUJBQW1CRCxZQUNyQjJDLFdBQVd2QixVQUFVQyxJQUFJLFVBQ3pCa0IsU0FBU08sYUFDVEMsZ0JBQ0YsR0FDQyJ9
