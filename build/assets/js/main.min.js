import{getPosts,getUser,slipPosts}from"./api.min.js";import{POSTS_LIST}from"./contst.min.js";const postsContainer=document.getElementsByClassName(POSTS_LIST)[0];async function posts(){const t=await getPosts();t.total<=slipPosts&&(triggerBtn.classList.add("hidden"),observer.disconnect()),t.posts.forEach((async t=>{const{userId:s}=t;setPostHTML(t,await getUserName(s))}))}function setPostHTML(t,s){const{title:e,body:n,reactions:o,tags:i}=t,a=document.createElement("div");a.classList.add("posts__item"),a.innerHTML=`<div class="posts__item-tags row">${getTags(i)}</div>\n                        <h2 class="posts__item-title">${e}</h2>\n                        <div class="posts__item-text">${n}</div>\n                        <div class="row space-between">\n                          <div class="posts__item-reactions">\n                            <div class="posts__item-reactions-icon"></div>\n                            <div class="posts__item-reactions-number">${o}</div>\n                          </div>\n                          <div class="posts__item-author">${s}</div>\n                        </div>`,postsContainer.appendChild(a)}function getTags(t){let s="";return t.forEach((t=>{s+=`<div class="posts__item-tag">${t}</div>`})),s}async function getUserName(t){try{const s=await getUser(t),{maidenName:e,lastName:n}=s;return`${e} ${n}`}catch(t){throw new Error(t)}}const options={root:document.querySelector(POSTS_LIST),rootMargin:"10px",threshold:.25};async function handleIntersect(t,s){t.forEach((t=>{t.isIntersecting&&posts()}))}const observer=new IntersectionObserver(handleIntersect,options),triggerBtn=document.getElementsByClassName("loading")[0];observer.observe(triggerBtn);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5taW4uanMiLCJuYW1lcyI6WyJnZXRQb3N0cyIsImdldFVzZXIiLCJzbGlwUG9zdHMiLCJQT1NUU19MSVNUIiwicG9zdHNDb250YWluZXIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJhc3luYyIsInBvc3RzIiwidG90YWwiLCJ0cmlnZ2VyQnRuIiwiY2xhc3NMaXN0IiwiYWRkIiwib2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwiZm9yRWFjaCIsIml0ZW0iLCJ1c2VySWQiLCJzZXRQb3N0SFRNTCIsImdldFVzZXJOYW1lIiwidXNlck5hbWUiLCJ0aXRsZSIsImJvZHkiLCJyZWFjdGlvbnMiLCJ0YWdzIiwibmV3RGl2IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImdldFRhZ3MiLCJhcHBlbmRDaGlsZCIsImh0bWxUYWciLCJ0YWciLCJ1c2VyIiwibWFpZGVuTmFtZSIsImxhc3ROYW1lIiwiZXJyb3IiLCJFcnJvciIsIm9wdGlvbnMiLCJyb290IiwicXVlcnlTZWxlY3RvciIsInJvb3RNYXJnaW4iLCJ0aHJlc2hvbGQiLCJoYW5kbGVJbnRlcnNlY3QiLCJlbnRyaWVzIiwiZW50cnkiLCJpc0ludGVyc2VjdGluZyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSJdLCJzb3VyY2VzIjpbIm1haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0UG9zdHMsIGdldFVzZXIsIHNsaXBQb3N0cyB9IGZyb20gJy4vYXBpLm1pbi5qcydcbmltcG9ydCB7IFBPU1RTX0xJU1QgfSBmcm9tICcuL2NvbnRzdC5taW4uanMnXG5jb25zdCBwb3N0c0NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoUE9TVFNfTElTVClbMF07XG5cbmFzeW5jIGZ1bmN0aW9uIHBvc3RzKCkge1xuICBjb25zdCBwb3N0cyA9IGF3YWl0IGdldFBvc3RzKClcblxuICBpZiAocG9zdHMudG90YWwgPD0gc2xpcFBvc3RzKSB7XG4gICAgdHJpZ2dlckJ0bi5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKVxuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIHBvc3RzLnBvc3RzLmZvckVhY2goYXN5bmMgKGl0ZW0pID0+IHtcbiAgICBjb25zdCB7IHVzZXJJZCB9ID0gaXRlbVxuICAgIGNvbnN0IHVzZXJOYW1lID0gYXdhaXQgZ2V0VXNlck5hbWUodXNlcklkKTtcbiAgICBzZXRQb3N0SFRNTChpdGVtLCB1c2VyTmFtZSlcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldFBvc3RIVE1MKGl0ZW0sIHVzZXJOYW1lKSB7XG4gIGNvbnN0IHsgdGl0bGUsIGJvZHksIHJlYWN0aW9ucywgdGFncyB9ID0gaXRlbTtcblxuICBjb25zdCBuZXdEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBuZXdEaXYuY2xhc3NMaXN0LmFkZCgncG9zdHNfX2l0ZW0nKVxuICBuZXdEaXYuaW5uZXJIVE1MID0gYDxkaXYgY2xhc3M9XCJwb3N0c19faXRlbS10YWdzIHJvd1wiPiR7Z2V0VGFncyh0YWdzKX08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxoMiBjbGFzcz1cInBvc3RzX19pdGVtLXRpdGxlXCI+JHt0aXRsZX08L2gyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBvc3RzX19pdGVtLXRleHRcIj4ke2JvZHl9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicm93IHNwYWNlLWJldHdlZW5cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBvc3RzX19pdGVtLXJlYWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwb3N0c19faXRlbS1yZWFjdGlvbnMtaWNvblwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwb3N0c19faXRlbS1yZWFjdGlvbnMtbnVtYmVyXCI+JHtyZWFjdGlvbnN9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicG9zdHNfX2l0ZW0tYXV0aG9yXCI+JHt1c2VyTmFtZX08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PmBcblxuICBwb3N0c0NvbnRhaW5lci5hcHBlbmRDaGlsZChuZXdEaXYpXG59XG5cbmZ1bmN0aW9uIGdldFRhZ3ModGFncykge1xuICBsZXQgaHRtbFRhZyA9ICcnXG4gIHRhZ3MuZm9yRWFjaCh0YWcgPT4ge1xuICAgIGh0bWxUYWcgKz0gYDxkaXYgY2xhc3M9XCJwb3N0c19faXRlbS10YWdcIj4ke3RhZ308L2Rpdj5gXG4gIH0pXG5cbiAgcmV0dXJuIGh0bWxUYWc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFVzZXJOYW1lKHVzZXJJZCkge1xuICB0cnkge1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBnZXRVc2VyKHVzZXJJZClcbiAgICBjb25zdCB7IG1haWRlbk5hbWUsIGxhc3ROYW1lIH0gPSB1c2VyXG4gICAgcmV0dXJuIGAke21haWRlbk5hbWV9ICR7bGFzdE5hbWV9YFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvcilcbiAgfVxufVxuXG5jb25zdCBvcHRpb25zID0ge1xuICByb290OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFBPU1RTX0xJU1QpLFxuICByb290TWFyZ2luOiAnMTBweCcsXG4gIHRocmVzaG9sZDogMC4yNVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVJbnRlcnNlY3QoZW50cmllcywgb2JzZXJ2ZXIpIHtcbiAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgcG9zdHMoKVxuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZUludGVyc2VjdCwgb3B0aW9ucyk7XG5jb25zdCB0cmlnZ2VyQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbG9hZGluZycpWzBdXG5vYnNlcnZlci5vYnNlcnZlKHRyaWdnZXJCdG4pO1xuIl0sIm1hcHBpbmdzIjoiT0FBU0EsU0FBVUMsUUFBU0MsY0FBaUIsc0JBQ3BDQyxlQUFrQixrQkFDM0IsTUFBTUMsZUFBaUJDLFNBQVNDLHVCQUF1QkgsWUFBWSxHQUVuRUksZUFBZUMsUUFDYixNQUFNQSxRQUFjUixXQUVoQlEsRUFBTUMsT0FBU1AsWUFDakJRLFdBQVdDLFVBQVVDLElBQUksVUFDekJDLFNBQVNDLGNBR1hOLEVBQU1BLE1BQU1PLFNBQVFSLE1BQU9TLElBQ3pCLE1BQU1DLE9BQUVBLEdBQVdELEVBRW5CRSxZQUFZRixRQURXRyxZQUFZRixHQUNULEdBRTlCLENBRUEsU0FBU0MsWUFBWUYsRUFBTUksR0FDekIsTUFBTUMsTUFBRUEsRUFBS0MsS0FBRUEsRUFBSUMsVUFBRUEsRUFBU0MsS0FBRUEsR0FBU1IsRUFFbkNTLEVBQVNwQixTQUFTcUIsY0FBYyxPQUN0Q0QsRUFBT2QsVUFBVUMsSUFBSSxlQUNyQmEsRUFBT0UsVUFBWSxxQ0FBcUNDLFFBQVFKLG1FQUNWSCxpRUFDQUMsc1JBSWdCQyx3R0FFWkgsMENBRzFEaEIsZUFBZXlCLFlBQVlKLEVBQzdCLENBRUEsU0FBU0csUUFBUUosR0FDZixJQUFJTSxFQUFVLEdBS2QsT0FKQU4sRUFBS1QsU0FBUWdCLElBQ1hELEdBQVcsZ0NBQWdDQyxTQUFHLElBR3pDRCxDQUNULENBRUF2QixlQUFlWSxZQUFZRixHQUN6QixJQUNFLE1BQU1lLFFBQWEvQixRQUFRZ0IsSUFDckJnQixXQUFFQSxFQUFVQyxTQUFFQSxHQUFhRixFQUNqQyxNQUFPLEdBQUdDLEtBQWNDLEdBQzFCLENBQUUsTUFBT0MsR0FDUCxNQUFNLElBQUlDLE1BQU1ELEVBQ2xCLENBQ0YsQ0FFQSxNQUFNRSxRQUFVLENBQ2RDLEtBQU1qQyxTQUFTa0MsY0FBY3BDLFlBQzdCcUMsV0FBWSxPQUNaQyxVQUFXLEtBR2JsQyxlQUFlbUMsZ0JBQWdCQyxFQUFTOUIsR0FDdEM4QixFQUFRNUIsU0FBUzZCLElBQ1hBLEVBQU1DLGdCQUNSckMsT0FDRixHQUVKLENBRUEsTUFBTUssU0FBVyxJQUFJaUMscUJBQXFCSixnQkFBaUJMLFNBQ3JEM0IsV0FBYUwsU0FBU0MsdUJBQXVCLFdBQVcsR0FDOURPLFNBQVNrQyxRQUFRckMifQ==
